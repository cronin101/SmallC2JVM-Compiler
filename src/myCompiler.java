import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashMap;

import org.antlr.runtime.tree.CommonTree;

public class myCompiler {
	
	public String getTypeFromTIDENT(CommonTree tident){
		return tident.getChild(0).getChild(0).getText();	
	}
	
	public String getNameFromTIDENT(CommonTree tident){
		return tident.getChild(1).getChild(0).getText();
	}
	
	//Used to end process cleanly on error
	public void semError(String error){
		System.out.printf("SEMANTIC ERROR: %s\n", error);
		System.exit(1);
	}
	
	//Finds all global declarations and stores them in a name => type HashMap
	public HashMap<String,String> globalVars(CommonTree ast){
		
		HashMap<String,String> gVars = new HashMap<String,String>();
		
		CommonTree declarationtree = null;
		
		ArrayList<CommonTree> declarations = new ArrayList<CommonTree>();
		
		//Find the subtree that holds declarations
		for (int i = 0; i < ast.getChildCount(); i++){
			String title = ast.getChild(i).getText();
			if (title == "DECLARATION"){
				declarationtree = (CommonTree) ast.getChild(i);
			}
		}
		//Strip IDENT subtrees from subtree and push these onto an ArrayList
		if (declarationtree != null){
			for (int i = 0; i < declarationtree.getChildCount();i++){
				String title = declarationtree.getChild(i).getText();
				if (title == "TIDENT"){
					declarations.add((CommonTree) declarationtree.getChild(i));
				}
			}
		//No global variables.
		} else {
			System.out.println("No global Variables");
			return null;
		}
		
		//If still running, IDENT subtrees are in ArrayList
		if (declarations.size() > 0){
			for (CommonTree declaration:declarations){
				String type = getTypeFromTIDENT(declaration);
				String name = getNameFromTIDENT(declaration);
				//CHECK THAT GVAR DOES NOT ALREADY EXIST WITH SAME NAME
				if (gVars.containsKey(name)){
					semError("Duplicate global variable '"+name+"'");
				}
				gVars.put(name, type);
			}
		//No IDENT subtrees found
		} else {
			System.out.println("No global Variables");
			return null;
		}
		
		return gVars;
	}
	
	public ArrayList<Procedure> getProcedures(CommonTree ast){
		ArrayList<Procedure> procedures = new ArrayList<Procedure>();
		//Find the subtree that holds declarations
		for (int i = 0; i < ast.getChildCount(); i++){
			String title = ast.getChild(i).getText();
			if (title == "PROCEDURE"){
				Procedure procedure = new Procedure();
				procedure.subtree = (CommonTree) ast.getChild(i);
				procedures.add(procedure);
			}
		}
		return procedures;
	}
	
	//returns the main procedure generated by stripping from the ast
	public Procedure getMain(CommonTree ast){
		Procedure procedure = new Procedure();
		for (int i = 0; i < ast.getChildCount(); i++){
			String title = ast.getChild(i).getText();
			if (title == "ENTRYPOINT"){
				procedure.subtree = (CommonTree) ast.getChild(i);
				procedure.setName("main");
				addDeclarations(procedure);
				addStatements(procedure);
				return procedure;
			}
		}
		semError("Main not found");
		return null;
	}
	

	public void nameProcedure(Procedure procedure){
		for (int i = 0; i < procedure.subtree.getChildCount();i++){
			//Name of Procedure extracted
			if (procedure.subtree.getChild(i).getText() == "NAME"){
				procedure.setName(procedure.subtree.getChild(i).getChild(0).getText());
			}
		}
	}
	
	public void addArguments(Procedure procedure){
		for (int j = 0; j < procedure.subtree.getChildCount(); j++){
			//Arguments for procedure found
			if (procedure.subtree.getChild(j).getText() == "ARGUMENTS"){
				CommonTree arguments = (CommonTree) procedure.subtree.getChild(j);
				if (arguments.getChildCount() == 0){
					//System.out.printf("%s has no arguments!\n", procedure.getName());
				} else{ 
					//TIDENT subtrees
					for (int k = 0; k < arguments.getChildCount();k++){
						CommonTree tident = (CommonTree) arguments.getChild(k);
						String name = getNameFromTIDENT(tident);
						String type = getTypeFromTIDENT(tident);
						//Duplicate Assignment Name
						if (procedure.isDeclared(name)){
							semError("TIDENT "+name+" is used more than once in arguments for "+procedure.getName());
						//Fresh Local Assignment for Procedure
						} else {
							procedure.addArg(name, type);
						}
					}
				}
			}
		}
	}
	
	public void addType(Procedure procedure){
		for(int i = 0; i < procedure.subtree.getChildCount(); i++){
			if (procedure.subtree.getChild(i).toString().contains("TYPE")){
				procedure.setType(procedure.subtree.getChild(i).getChild(0).getText());
			}
		}
	}
	
	public void addDeclarations(Procedure procedure){
		//Search for FUNCBODY within procedure tree
		for (int i = 0; i < procedure.subtree.getChildCount(); i++){
			if (procedure.subtree.getChild(i).getText() == "FUNCBODY"){
				CommonTree body = (CommonTree) procedure.subtree.getChild(i);
				//Search for DECLARATION subtree within FUNCBODY
				for (int j = 0; j< body.getChildCount(); j++){
					if (body.getChild(j).getText() == "DECLARATION"){
						CommonTree decs = (CommonTree) body.getChild(j);
						//For each declaration, get it's name and type
						for (int k = 0; k < decs.getChildCount(); k++){
							CommonTree tident = (CommonTree) decs.getChild(k);
							String name = getNameFromTIDENT(tident);
							String type = getTypeFromTIDENT(tident);
							//Duplicate Assignment Name
							if (procedure.isDeclared(name)){
								semError("TIDENT "+name+" is redeclared in functionbody of "+procedure.getName());
							//Fresh Local Assignment for Procedure
							} else {
								procedure.addDec(name, type);
							}
						}
					}
				}
			}
		}
	}
	

	// Returns whether an expression tree is a semantically valid tree of integers
	public boolean isExpression(CommonTree input, Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		//BASE CASE
		//integer function calls
		if (input.getText() == "CALL"){
			if(lookupProcedureType((input.getChild(0).getChild(0).getText()),procedures).contentEquals("int")){
				checkCall(input, procedure, gVars, procedures);
				return true;
			}
		}
		//Only integer literals can be an input with no children
		if (input.getChildCount() == 0){
			return true;
		//If not a literal...
		} else {
			//IF: the input is a variable...
			if (input.getText() == "NAME"){
				//Type is checked
				String realtype = lookupTypeInScope(input.getChild(0).getText(),procedure,gVars);
				//Pass
				if (realtype.contentEquals("int")){
					return true;
				//Fail
				} else {
					semError("Non integer variable within expression tree");
				}
			}
			//NOW THE FUN BIT WITH RECURSION OVER EXPRESSION TREES
			String[] operators = {"+","-","/","*","%"};
			for (String operator : operators){
				if (input.getText().contentEquals(operator)){
					boolean left = isExpression((CommonTree) input.getChild(0), procedure, gVars, procedures);
					boolean right = isExpression((CommonTree) input.getChild(0), procedure, gVars, procedures);
					if (left && right){
						return true;
					}
				}

			}
		  if (input.getText().contentEquals("NEG")){
            isExpression((CommonTree) input.getChild(0), procedure, gVars, procedures);
            return true;
        }}
		semError("Incorrectly formed integer expression");
		return false;
	}

	public boolean isComparison(CommonTree input, Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		
		return false;
	}
	
	
	//Main function for taking a file input and returning a stream of ByteCode
	//TODO handle the output
	public void compileFromFile(String filename, FileOutputStream output, String name) throws IOException{
		//Parser from previous assignment
		myParser parser = new myParser();
		//Returns AST of source code
		CommonTree inputAST = parser.getASTFromSource(filename);
		//Declarations extracted
		HashMap<String,String> gVars = globalVars(inputAST);
		
		ArrayList<Procedure> procedures = getProcedures(inputAST);
		for (Procedure procedure : procedures){
			nameProcedure(procedure);
			addType(procedure);
			addArguments(procedure);
			addDeclarations(procedure);
			addStatements(procedure);
			checkAssigns(procedure,gVars,procedures);
			checkIO(procedure,gVars,procedures);
			checkCalls(procedure,gVars,procedures);
			checkComparisons(procedure,gVars,procedures);
			System.out.println("Finished checking "+procedure.getName());
		}
		Procedure main = getMain(inputAST);
		checkAssigns(main,gVars,procedures);
		checkIO(main,gVars,procedures);
		checkCalls(main,gVars,procedures);
		checkComparisons(main,gVars,procedures);
		System.out.println("Finished checking main");
		System.out.println("Finished checking se" +
				"mantics, bytecode generation can begin");
		Program program = new Program(gVars,procedures,main);
		try{
			program.getBytecode(output,name);
		} catch (Exception e){
			e.printStackTrace();
		}
		System.out.printf("Finished outputting bytecode to %s.class\n",name);
	}
	
	private void checkComparison(CommonTree comparison, Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		if (comparison.getChildCount() == 2){
			//Both int or both char
			String type1 = checkTypes((CommonTree) comparison.getChild(0), procedure, gVars, procedures);
			String type2 = checkTypes((CommonTree) comparison.getChild(1), procedure, gVars, procedures);
			if (type1.contentEquals(type2)){
				return;
			}
			semError("Comparison between two unmatched types");
		}
		//System.out.println("Anything has a true/false value so pass");
	}
	
	private void checkComparisons(Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		for (CommonTree comparison : procedure.getComparisons()){
			checkComparison(comparison, procedure, gVars, procedures);
		}
	}
	
	private String lookupProcedureType(String name, ArrayList<Procedure> procedures){
		for (Procedure procedure : procedures){
			if (procedure.getName().contentEquals(name)){
				return procedure.getType();
			}		
		}
		semError("Procedure called but never declared: "+name);
		return null;
	}
		
	private void checkCall(CommonTree call, Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		String procedurename = (call.getChild(0).getChild(0).getText());
		//Find procedure referenced
		for (Procedure pro : procedures){
			if (procedurename.contentEquals(pro.getName())){
				CommonTree calledArgs = (CommonTree) call.getChild(1);
				for (int i = 0; i < calledArgs.getChildCount(); i++){
					String calledParam = calledArgs.getChild(i).getChild(0).getText();
					String actualParam = pro.getArgList().get(i);
					if (!lookupTypeInScope(calledParam, procedure, gVars).contentEquals(lookupTypeInScope(actualParam,pro,gVars))){
						semError("Argument types don't match inside "+procedure.getName());
					}
				}
			}
		}
	}
	
	private void checkCalls(Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		for (CommonTree call : procedure.getCalls()){
			checkCall(call, procedure, gVars, procedures);
		}
	}
	
	private void checkIO(Procedure procedure, HashMap<String, String> gVars, ArrayList<Procedure> procedures) {
		for (CommonTree io : procedure.getIO()){
			//CASE: readc, outputc <- require chars
			if (io.getChild(0).getChild(0).getText().contains("readc")){
				if (lookupTypeInScope(io.getChild(1).getChild(0).getText(), procedure, gVars).contentEquals("char")){
					return;
				}
				semError("readc variable of incorrect type, char needed and not found");
			}
			
			if (io.getChild(0).getChild(0).getText().contains("outputc")){
				//output c can be a char literal as well
				if (io.getChild(1).getText().contains("CHAR")){
					return;
				}
				//or a variable
				if (lookupTypeInScope(io.getChild(1).getChild(0).getText(), procedure, gVars).contentEquals("char")){
					return;
				}
				semError("outputc input of incorrect type, char needed and not found");
			}
			
			if (io.getChild(0).getChild(0).getText().contains("read")){
				//integer variable needed
				if (lookupTypeInScope(io.getChild(1).getChild(0).getText(), procedure, gVars).contentEquals("int")){
					return;
				}
				semError("'read' input of incorrect type, integer needed and not found");
			}
			
			if (io.getChild(0).getChild(0).getText().contains("output")){
				//integer variable or expression needed
				if (lookupTypeInScope(io.getChild(1).getChild(0).getText(), procedure, gVars).contentEquals("int")){
					return;
				}
				if (isExpression((CommonTree) io.getChild(1).getChild(0), procedure, gVars, procedures)){
					return;
				}
				semError("'output' input of incorrect type, integer or expression needed and not found");
			}
			
		}
	}

	private void addStatements(Procedure procedure){
		//Find FUNCBODY
		for (int i = 0; i < procedure.subtree.getChildCount(); i++){
			CommonTree body = (CommonTree) procedure.subtree.getChild(i);
			//Find STATEMENTS subtree
			for (int j = 0; j < body.getChildCount(); j++){
				if (body.getChild(j).getText() == "STATEMENTS"){
					//For each statement
					for (int k = 0; k < body.getChild(j).getChildCount(); k++){
						procedure.addStatement((CommonTree) body.getChild(j).getChild(k));
					}
				}
			}
		}
	}
	
	private void checkAssigns(Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures) {
		for (CommonTree assignment : procedure.getAssigns()){
			//Name of left hand side
			String lhs = getNameFromTIDENT(assignment);
			//Type of left hand side (exit on error if non existent)
			String dectype = lookupTypeInScope(lhs,procedure,gVars);
			CommonTree input = (CommonTree) assignment.getChild(2);
			//Checks if types match
			refactoredCheckTypes(dectype,input,procedure,gVars,procedures);
		}
	}

	private String checkTypes(CommonTree input, Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		if (checkTypeIsA("char",input,procedure,gVars,procedures)){
			return "char";
		}
		if (checkTypeIsA("int",input,procedure,gVars,procedures)){
			return "int";
		}
		semError("Couldn't find type for part of "+procedure.getName());
		return null;
	}
	
	private void refactoredCheckTypes(String dectype,CommonTree input, Procedure procedure, HashMap<String,String> gVars, ArrayList<Procedure> procedures){
		if (!checkTypeIsA(dectype,input,procedure,gVars,procedures)){
			semError("Type mismatch inside "+procedure.getName());
		}
	}
	
	
	
	private boolean checkTypeIsA(String dectype,CommonTree input, Procedure procedure, HashMap<String,String> gVars,ArrayList<Procedure> procedures){
		//CASE: CHARACTERS
		if (dectype.contentEquals("char")){
			//char function calls
			if (input.getText() == "CALL"){
				if(lookupProcedureType((input.getChild(0).getChild(0).getText()),procedures).contentEquals("char")){
					checkCall(input, procedure, gVars, procedures);
					return true;
				}
			}
			//Valid Char inputs are held below a 'CHR' node
			if (input.getText() == "CHR"){
				return true;
			//If not a CHR node...
			} else {
				//Could be a variable...
				if (input.getText() == "NAME"){
					//Type of variable is looked up wrt scope
					String realtype = lookupTypeInScope(input.getChild(0).getText(),procedure,gVars);
					//IF: The types match, exit with no error.
					if (realtype.contentEquals(dectype)){
						return true;
					//ELSE: The types do not match, exit with error.
					} else {
						return false;
					}
				}
				//If not variable... Must be an integer literal or expression.
				return false;
			}
		//CASE: INTEGERS
		} else {
			if (input.getText() == "CHR"){
				return false;
			}
			if (isExpression(input,procedure,gVars,procedures)){
				return true;
			}
		}
		//CASE: Not handled correctly by control flow yet
		return false;
	}
	
	private String lookupTypeInScope(String name, Procedure procedure, HashMap<String,String> gVars){
		if (procedure.isDeclared(name)){
			return procedure.typeLookup(name);
		}
		if (gVars.containsKey(name)){
			return gVars.get(name);
		}
		semError("Variable "+name+" assigned in "+procedure.getName()+" without previously being declared");
		return null;
	}
	
	//Entry Point
	public static void main(String[] args) throws IOException{
		//TODO MAKE SURE RETURN TYPES OF FUNCTIONS ARE CHECKED
		myCompiler compiler = new myCompiler();
    String name = args[0];
		String inputsource = name+".c";
		FileOutputStream output = new FileOutputStream(name+".class");
		compiler.compileFromFile(inputsource,output,name);
	}
}
